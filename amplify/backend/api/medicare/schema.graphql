# Medicare application schema

# Patient (main user base of the application) profile with basic attributes
# The profile is managed by the user
# TODO: Add further attributes [TBD]
# TODO: Enhance the authentication coordination for (Admins / Insurance Agents)
type Patient
@model
@auth(
  rules: [
    { allow: owner, ownerField: "id", operations:[create, read, update, delete]}
  ]
)
{
  id: ID!,
  name: String
}

# Doctor (physician) profile with basic attributes
# The profile is mainly managed by Adminstration (Application Admins / Insurance Agents)
# TODO: add pipeline functions to manage the object restrictions and sanity checks
type Doctor
@model
@auth(
  rules: [
    {allow: groups, groups: ["Admins"], operations: [read, create, update, delete]}
    {allow: groups, groups: ["Patients"], operations: [read]}
  ]
)
{
  id: ID!,
  insurance: [String],
  description: String,
  specializations: [String],
  name: String
}

# Working slots are managed by the Doctors
# TODO: add pipeline functions to ensure no overlap of slots
type DoctorWorkSlot
@model
@auth(
  rules:[
    { allow: owner, ownerField: "doctorID", operations:[create, read, update, delete]},
    { allow: groups, groups: ["Patients"], operations: [read]}
  ]
)
@key(name: "doctorWorkSlotByDoctor", fields: ["doctorID"], queryField: "doctorWorkSlotByDoctor")
{
 id: ID!,
 doctorID: ID!,
 doctor: Doctor! @connection(fields: ["doctorID"]),
 start_time: AWSDateTime,
 end_time: AWSDateTime,
 capacity: Int,
}

# Enum values for session reservations
enum SessionStatus {
  REQUESTED
  ACCEPTED
  REJECTED
}

# Video session reservation
# TODO: Add sanity functions and subscriptions to enable further notification before call
# TODO: allow visibility of reservations to the insurace agents [TBD]
type DoctorVideoSession
@model
@auth(
  rules: [
    { allow: owner, ownerField: "patientID", operations: [create, read]},
    { allow: owner, ownerField: "doctorID", operations: [update]}
  ]
)
@key(fields: ["id"])
@key(name: "doctorVideoSessionByDoctor", fields: ["doctorID"], queryField: "doctorVideoSessionByDoctor")
@key(name: "doctorVideoSessionByPatient", fields: ["patientID"], queryField: "doctorVideoSessionByPatient")
{
  id: ID!,
  doctorID: ID!,
  doctor: Doctor! @connection(fields: ["doctorID"]),
  patientID: ID!,
  patient: Patient! @connection(fields: ["patientID"]),
  start_time: AWSDateTime,
  end_time: AWSDateTime,
  status: SessionStatus
}

# Text session reservation
# TODO: Add sanity functions and subscriptions to enable further notification before chat session
# TODO: allow visibility of reservations to the insurace agents [TBD]
type DoctorTextSession
@model
@auth(
  rules: [
    { allow: owner, ownerField: "patientID", operations: [create, read]},
    { allow: owner, ownerField: "doctorID", operations: [update]}
  ]
)
@key(fields: ["id"])
@key(name: "doctorTextSessionByDoctor", fields: ["doctorID"], queryField: "doctorTextSessionByDoctor")
@key(name: "doctorTextSessionByPatient", fields: ["patientID"], queryField: "doctorTextSessionByPatient")
{
  id: ID!,
  doctorID: ID!,
  doctor: Doctor! @connection(fields: ["doctorID"]),
  patientID: ID!,
  patient: Patient! @connection(fields: ["patientID"]),
  start_time: AWSDateTime,
  end_time: AWSDateTime,
  status: SessionStatus
}

# Audio session reservation
# TODO: Add sanity functions and subscriptions to enable further notification before call
# TODO: allow visibility of reservations to the insurace agents [TBD]
type DoctorAudioSession
@model
@auth(
  rules: [
    { allow: owner, ownerField: "patientID", operations: [create, read]},
    { allow: owner, ownerField: "doctorID", operations: [update]}
  ]
)
@key(fields: ["id"])
@key(name: "doctorAudioSessionByDoctor", fields: ["doctorID"], queryField: "doctorAudioSessionByDoctor")
@key(name: "doctorAudioSessionByPatient", fields: ["patientID"], queryField: "doctorAudioSessionByPatient")
{
  id: ID!,
  doctorID: ID!,
  doctor: Doctor! @connection(fields: ["doctorID"]),
  patientID: ID!,
  patient: Patient! @connection(fields: ["patientID"]),
  start_time: AWSDateTime,
  end_time: AWSDateTime,
  status: SessionStatus
}
